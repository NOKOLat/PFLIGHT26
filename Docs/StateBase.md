# StateBase（部分実装付きの抽象基底クラス）

**StateBase** は、ドローンの異なる飛行モード（状態）間で**共通する処理をまとめた基底クラス**です。
部分実装により、各状態固有のロジックのみを実装することで、**コードの重複を削減**し、**保守性を向上**させます。


## 問題点

各飛行モード（状態A、B、C）が、ほぼ同じ処理フローを繰り返していました。

### 状態A（自動飛行：水平飛行）
1. **状態遷移判定** → 他の状態へ切り替えるか判定
2. **センサーデータ取得** → IMU、気圧計などから値を読む
3. **姿勢角計算** → センサーデータから現在の姿勢を計算
4. **制御計算** → PID制御（目標値はすべて0で水平飛行）
5. **PWM出力** → モーターに信号を送信

### 状態B（自動飛行：目標値設定）
1. **状態遷移判定** → 他の状態へ切り替えるか判定
2. **センサーデータ取得** → IMU、気圧計などから値を読む
3. **姿勢角計算** → センサーデータから現在の姿勢を計算
4. **制御計算** → PID制御（目標値はファイルから読み取る）
5. **PWM出力** → モーターに信号を送信

### 状態C（手動飛行）
1. **状態遷移判定** → 他の状態へ切り替えるか判定
2. **センサーデータ取得** → IMU、気圧計などから値を読む（平均化のため）
3. **姿勢角計算** → センサーデータから現在の姿勢を計算
4. **制御計算** → SBUS信号から直接PWM値を計算
5. **PWM出力** → モーターに信号を送信

**問題：**
- ステップ 2, 3, 5 は完全に同じ → **重複コード**
- 変更があると、すべての状態で修正が必要 → **保守性が低い**


## 解決策

**StateBase** という基底クラスに共通処理をまとめ、各状態は**固有のロジックのみを実装**します。

```
StateBase（基底クラス）
├─ 0. 状態遷移判定 [仮想関数] ← 各状態で実装
├─ 1. センサーデータ取得 [実装済み] ← 共通
├─ 2. 姿勢角計算 [実装済み] ← 共通
├─ 3. 制御計算 [仮想関数] ← 各状態で実装
└─ 4. PWM出力 [実装済み] ← 共通
```

### 各状態の実装内容

**StateA（自動飛行）**
```
StateA : StateBase
├─ 状態遷移判定を実装
└─ 制御計算：PID制御（目標値 = 0 で水平飛行）
```

**StateB（自動飛行）**
```
StateB : StateBase
├─ 状態遷移判定を実装
└─ 制御計算：PID制御（目標値 = ファイルから読み取る）
```

**StateC（手動飛行）**
```
StateC : StateBase
├─ 状態遷移判定を実装
└─ 制御計算：SBUS信号から直接PWM値を計算
```

---

## メリット

| メリット | 説明 |
|---------|------|
| **コード重複削減** | センサー取得、姿勢計算など共通処理が1箇所に |
| **保守性向上** | センサー処理の変更が必要なら、基底クラスのみ修正 |
| **実装効率化** | 新しい飛行モードを追加する際、固有部分だけ実装すればOK |
| **バグ減少** | 共通部分のテストが一度済めば、すべての状態で有効 |

---

## 仮想関数について

- **`状態遷移判定()`** → 各状態で条件を定義（例：条件Xなら状態Bへ）
- **`制御計算()`** → 各状態で異なる制御ロジックを実装（PID vs 手動など）

基底クラスはこれらのインターフェースを定義し、各状態がオーバーライドして実装します。


## 実装時のポイント

- StateBaseごとの共通処理を読み、共通処理に追加すべきか、各クラスで実装すべきかを判断する