# C++のコーディングルール

## ファイル構成

### ヘッダーファイル/ソースファイルの規約

- 機能があまりにも少ない場合を除き、クラス宣言はヘッダーファイル（.h）に、クラスの実装はソースファイル（.cpp）に分ける。
- ヘッダーファイルには、クラス宣言、関数プロトタイプ、定数宣言などのインターフェースを含める。
- ソースファイルには、クラスの実装、関数の定義、ロジックの実装を含める。

### ファイル命名規則

- ファイル名は小文字で、単語の区切りはアンダースコア（snake_case）を使用する。
- ただし、インクルードガードの命名規則は、ファイル名を大文字に変換し、単語の区切りをアンダースコアにする（UPPER_SNAKE_CASE）を使用する。
```cpp
// ファイル名: my_class.h
#ifndef MY_CLASS_H
#define MY_CLASS_H
```

## 命名規則

### クラス、関数、変数の命名

1. クラス名は大文字で始まり、単語の区切りは大文字（PascalCase）を使用する。
2. 関数名は小文字で始まり、単語の区切りは大文字（camelCase）を使用する。
3. 変数名は小文字で始まり、単語の区切りはアンダースコア（snake_case）
4. クラス宣言、スコープ宣言（public、private、protected）はインデントと改行をする

```cpp
Class MyClass {

    public:

        void myFunction();
        void anotherFunction();

    private:

        uint8_t my_variable;
        uint8_t another_variable;
}

### 定数、マクロの命名

1. 定数はすべて大文字で、単語の区切りはアンダースコア（UPPER_SNAKE_CASE）を使用する。
2. マクロはすべて大文字で、単語の区切りはアンダースコア（UPPER_SNAKE_CASE）を使用する。
3. ただしマクロの使用は可読性を下げる可能性があるので、constexprやenum classの使用を推奨する。
4. 例外としてインクルードガードはファイル名を大文字に変換し、単語の区切りをアンダースコアにする（UPPER_SNAKE_CASE）を使用する。
```cpp
#define MAX_BUFFER_SIZE 1024
constexpr int MAX_BUFFER_SIZE = 1024;
```

### アンダースコアの使い方

1. スネークケースでのみ使用し、クラス名や関数名には使用しない。
2. 定数やマクロの命名に使用する場合はすべて大文字にする。
3. 変数名に使用する場合はすべて小文字で、単語の区切りに使用する。

## インデント・フォーマット

### インデント幅（スペース/タブ）
1. インデントはスペース4つを使用する。
2. 処理の塊ごとにインデントを追加する。
3. インデントはコードの構造を明確にするために使用する

### 行の長さ制限

1. 基本的に1行にかけるのであれば書くことにするが、引数の多い関数はその限りでない
2. １行が長くなる場合は、適切なところで改行し、インデントを追加する。
3. このような書き方をすることができる（この関数の場合は１行で収まるが例としてこのように書いている）
```cpp
void myFunction(int arg1, int arg2, int arg3, int arg4) {

    // 合計と平均の計算
    int sum = arg1 + arg2 + arg3 + arg4;
    float average = static_cast<float>(sum) / 4;

    // 標準偏差の計算
    float standard_deviation = std::sqrt(
        (std::pow(arg1 - average, 2) + 
         std::pow(arg2 - average, 2) + 
         std::pow(arg3 - average, 2) + 
         std::pow(arg4 - average, 2)) / 4
    );

    // 分散の計算
    float variance = std::pow(standard_deviation, 2);

    return;
}

myFunction(
    arg1, 
    arg2, 
    arg3, 
    arg4
);
```

### 括弧の配置
1. 関数宣言や制御構文の初めの括弧は同じ行に配置する。
2. 関数宣言や制御構文の終わりの括弧は新しい行に配置する。
3. 
```cpp
void myFunction() {

    if (condition) {

        // code
    } 
    else {

        // code
    }
}
```

## コメント・ドキュメント

### コメントスタイル
1. 単一行コメントは//を使用する。
2. ５行までなら//を使用して複数行コメントを書くことができる。
3. ５行以上の複数行コメントは/* */を使用する。
4. コメントはすべて日本語で、処理の塊ごとに書く

### 関数/クラスのドキュメント
1. 関数やクラスの宣言の前に、その目的、引数、戻り値、例外などを説明するドキュメントコメントを書く。
2. ドキュメントコメントは、関数やクラスの使用方法を明確にするために使用する。
3. ドキュメントコメントは、関数やクラスの宣言の前に書くことができる。
```cpp
// 関数の目的
// [in] int arg1 - 引数1の説明
// [in] int arg2 - 引数2の説明
// [out] int* arg3 - 引数3の説明
// [return] bool 戻り値の説明
bool myFunction(int arg1, int arg2, int* arg3);
```

### 複雑なロジックの説明

1. 複雑なロジックやアルゴリズムを実装する場合は、そのロジックやアルゴリズムの説明をコメントで書く。
2. コメントは、コードの理解を助けるために使用する。

## スコープ・アクセス制御

### グローバル変数の使用

1. グローバル変数の使用は避ける。
2. グローバル変数が必要な場合は、名前空間を使用
3. グローバル変数は、クラスの静的メンバー変数として定義することができる。

### public/private/protectedの使い分け

1. クラスのメンバー変数はprivateにする。
2. クラスのメンバー関数はpublicにする。
3. クラスの継承関係に応じて、protectedを使用する
4. なるべく最小のスコープになるように定義し、不明な場合はユーザーに質問する

### スタティックメンバーの規約
1. クラスのスタティックメンバーは、クラス宣言の中で宣言し、ソースファイルで定義する。
2. 現状スタティックメンバーを使用したい実装は少ないので、基本的に使用しないことになる。
3. 例外時はユーザーに確認する。

## 関数設計

### 関数の長さ制限
1. 関数はできるだけ短く、単一の責任を持つように設計する。
2. ハードウェアがかかわったり、複数のクラスを動かすユーティリティはその限りではない
3. printfなどのデバック機能、改行は行数としてカウントしなくていいので、節約に動かないこと

### パラメータ数の制限
1. 関数のパラメータはできるだけ少なくする。
2. パラメータが10個を超える場合は構造体化を提案すること

### const/参照の使い方
1. 関数の引数が変更されない場合は、constを使用する。
2. データの用途が使用のみであれば、const参照を使用する。

## メモリ管理

### ポインタ/スマートポインタの使い分け

1. 生のポインタは、所有権を持たない場合や、関数の引数として使用する場合に使用する。
2. マイコンなのでstd::shared_ptrは使用せず、unique_ptrはクラスのインスタンスなどでのみ使用する
3. 可能性であればstd::optionalを使用することも検討する
4. 基本は静的確保をするが、コードを簡潔にするために動的確保をすることもあるので、ユーザーに確認する

### new/deleteの規約

1. C++17以降を使用できるので、ライブラリの実装以外で使用しない


## エラー処理

### 例外処理のポリシー

1. 例外処理は使用しない。
2. エラーは、関数の戻り値や出力引数を使用
3. エラーコードは、定数やenum classを使用して定義する。

### エラーリターン値の使い方
1. エラーリターン値は、関数の戻り値や出力引数を使用する。
2. エラーコードは、true/falseを使用する
3. エラーパターンが多いときはprintfを使用したり、エラーコードを定数やenum classで定義することも検討する。　
4. エラーコードを定数やenum classで定義する場合は、ユーザーに確認する。
5. インスタンスチェックなどは初回起動時や生成直後に1度行えば十分なことが多いので、エラーコードを返す必要がないこともある。ユーザーに確認する。（基本的に1度より多い回数生成するインスタンスが存在しないため）